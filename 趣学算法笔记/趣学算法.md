# 趣学算法

## Chapter1

时间复杂度：考察一个算法通常考察最坏情况，而不是考察最好情况，最坏情况对衡量算法的好坏具有实际意义。

空间复杂度: 辅助空间使衡量空间复杂度的关键因素。

注意！
在递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。

阶乘是典型的递归调用问题，递归包括递推和回归。递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。

常见的算法时间复杂度有以下几类:
- 常数阶
$$O(1)$$
- 多项式阶
很多算法的时间复杂度是多项式，通常用$$O(n)$$, $$O(n^2)$$, $$O(n^3)$$ 等表示。
- 指数阶
如: $$O(2^n)$$, $$O(n!)$$, $$O(n^n)$$ 等。
- 对数阶
-对数阶时间复杂度运行效率较高，常见的有$$O(logn)$$, $$O(nlogn)$$。

注意！

斐波那契数列既可以使用递归方法求解(包含大量重复计算，因此时间复杂度是指数阶)，也可以使用动态规划求解$$O(n)$$。

算法策略: 贪心，分治，动态规划， 线性规划，搜索等；

本章主要说明以下问题:
- 将程序的执行次数作为时间复杂度的衡量标准；
- 时间复杂度通常用渐近上界符号$$f(n)$$ 表示；
- 衡量算法的好坏通常考察算法的最坏情况；
- 空间复杂度只计算辅助空间；
- 递归算法的空间复杂度要计算递归使用的栈空间；
- 设计算法时尽量避免爆炸级增量复杂度；

## Chapter2 贪心算法

### 2.1 人之初，性本贪

一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。

在贪心算法中，注意以下几个问题:
- 一旦做出选择，不可以反悔；
- 有可能得到的不是最优解，而是最优的近似解；
- 选择什么样的贪心策略，直接决定算法的好坏；

贪心算法具有2个重要特征:
- 贪心选择；
运用贪心策略解决的问题在程序运行过程中无回溯过程。
- 最优子结构；
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。

贪心算法的过程:
- 贪心策略
首先要确定贪心策略，选择当前看上去最好的一个方案。
- 局部最优解
根据贪心策略，一步一步地得到局部最优解。
- 全局最优解
把所有全部局部最优解合并成为原来问题的一个最优解。

比如冒泡算法使用了贪心算法。

### 2.2 加勒比海盗船---最优装载问题

问题分析：
要求装载的物品的数量尽可能的多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。采用重量最轻者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题你的最优解。

#### 2.2.6 算法解析及优化拓展
- 算法复杂度分析:
1. 时间复杂度: 排序平均复杂度$$O(nlogn)$$, 输入和贪心策略$$O(n)$$, 因此时间复杂度为 $$O(n+nlogn)$$。
2. 空间复杂度：$$O(1)$$。

### 2.3 阿里巴巴与四十大盗---背包问题
#### 2.3.1 问题分析
假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v, 毛驴运载能力有限， 只能运走m重量的宝物，一种宝物只能拿走一件，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢?
#### 2.3.2 算法设计
- 将n种宝物的重量和价值存储在结构体中(包含重量，价值，性价比3个成员)，同时求出每种宝物的性价比也存储在对应的结构体中，将其按照性价比从高到底排序。
- 根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。
#### 2.3.6 算法解析及优化拓展
- 算法复杂度分析 
1. 时间复杂度: 该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为$$O(nlogn)$$。 
2. 空间复杂度: 空间主要耗费在存储宝物的性价比，空间复杂度为$$O(n)$$。

**在物品不可分割，没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。**
**物品可分割的装载问题称为背包问题，物体不可分割的装载问题称之为0-1背包问题。**
**在物品不可分割的情况下，即0-1背包问题，已经不具有贪心选择性质，原问题的整体最优解无法通过一系列局 部最优的选择得到，因此这类问题得到的是近似解。如果一个问题不要求得到最优解，而只需要一个最优解的近似解，则不管该问题有没有贪心选择性质都可以使用贪心算法。**

### 2.4 高级钟点秘书---会议安排
#### 2.4.1 问题分析
贪心策略: 每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排。
#### 2.4.2 算法设计
- 初始化: 将n个会议的开始时间，结束时间存放在结构体数组中，如果需要知道选择了哪些会议，还需要在结构体中增加会议编号，然后按照结束时间从小到大排序，结束时间相等时，按开始时间从大到小排序；
- 根据贪心策略就是选择第一个具有最早结束时间的会议，用last记录刚选中会议的结束时间；
- 选择第一个会议之后，依次从剩余下未安排的会议中选择，如果会议i开始时间大于等于最后一个选中的会议的结束时间last，那么会议i与选中的会议相容，可以安排，更新last为刚选中会议的结束时间；否则，舍弃会议i,检查下一个会议是否可以安排。
#### 2.4.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度:
排序的平均时间复杂度为$$O(nlogn)$$, 会议选择的时间复杂度为$$O(n)$$ , 因此总的时间复杂度为$$O(n+nlogn) = O(nlogn)$$ 。
2. 空间复杂度: 
在该算法中，结构数组作为输入数据，不计算在空间复杂度内。因此该程序空间复杂度为常数阶，即$$O(1)$$。
### 2.5 一场说走就走的旅行---最短路径

#### 2.5.1 问题分析
根据题目描述可知，这是一个求单源最短路径的问题。给定有向带权图$$G = (V, E)$$, 其中每条边的权是非负实数。此外，给定V中的一个顶点，称为源点。现在要计算从源到所有其他各个顶点的最短路径长度，这里路径长度指路上各边的权之和。使用Dijkstra算法。
#### 2.5.2 算法设计
Dijkstra算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，在参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径。
Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径，将其连接的V-S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，Dist[]就是从源到所有其他顶点之间的最短路径长度。
#### 2.5.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度:
算法的时间复杂度为$$O(n^2)$$。
2. 空间复杂度:
实现该算法所需的辅助空间包含为数组flag, 变量i, j ,t 和temp所分配的空间，因此，空间复杂度为$$O(n)$$。
- 算法优化拓展
使用优先队列。
优先队列概念:
普通优先队列是一种先进先出的数据结构，元素在队尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。
优先队列(priority queue)具有最高级先出的行为特征。优先队列是0个或多个元素的集合，每个元素都有一个优先权或值。
在最小优先队列(min priority queue)中，查找操作用来搜索优先权最小的元素，删除操作用来删除该元素；对于最大优先队列(max priority queue), 查找操作用来搜索优先权最大的元素,删除操作用来删除该元素。(默认是最大优先队列)
在集合V-S中寻找距离源点u最近的顶点t,其时间复杂度为$$O(n)$$，如果我们使用优先队列，则可以把是按复杂度降为$$O(logn)$$。
**注意!**
使用优先队列的时间复杂度:
1. 使用邻接矩阵存储
语句总的执行次数为$$n*logn + n^2*logn$$， 算法的时间复杂度为$$O(n^2logn)$$。
2. 使用邻接表存储
总的时间复杂度为$$O(n*logn + E*logn)$$，如果 $$E \geq n$$，则时间复杂度为$$O(E*logn)$$。
优先队列中尽管有重复的结点，但重复结点最坏是$$n^2$$, $$logn^2 = 2logn$$，并不改变时间复杂度的数量级。
想一想，还能不能把时间复杂度在降低呢? 如果我们使用斐波那契堆，那么松弛操作的时间复杂度$$O(1)$$，总的时间复杂度为$$O(n*logn+E)$$。每个结点的邻接边加起来为边数E。
**!!!在STL容器中，优先队列的底层，是按照堆的形式实现的(默认为大根堆)。**

### 2.6 神秘电报密码---哈夫曼编码
#### 2.6.2 算法设计
哈夫曼编码的基本思想是以字符的使用频率作为权构建一颗哈夫曼树，然后利用哈夫曼树对字符进行编码。构建一棵哈夫曼树，是将所有编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式,通过n-1次的合并运算后构建出的一棵树，核心思想是权值越大的叶子结点离根越近。
哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中。
***
*注意!!! C++中数组作为函数参数是传地址，即在子函数中可以直接修改数组中的内容。(即不会在子函数中在复制一个，内容相同的数组。但是需要注意，在传地址时，要同时传数组的大小。)*
***
#### 2.6.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度: 
该算法的时间复杂度为$$O(n^2)$$。
2. 空间复杂度:
该算法的空间复杂度为$$O(n*MAXBIT)$$。

### 2.7 沟通无限校园网---最小生成树
#### 2.7.1 问题分析
1. 子图: 从原图中选中一些顶点和边组成的图，称为原图的子图。
2. 生成子图: 选中一些边和所有顶点组成的图，称为原图的生成子图。
3. 生成树: 如果生成子图恰好是一棵树，则称为生成树。
4. 最小生成树: 权值之和最小的生成树，则称为最小生成树。
本题就是最小生成树求解问题。
#### 2.7.2 算法设计
如果在一个图中深度搜索或广度搜素有没有回路，是一件繁重的工作。有一个很好的办法---避圈法。在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。
#### 2.7.6 算法解析
1. 时间复杂度: 算法的时间复杂度为$$O(n^2)$$。
2. 空间复杂度: 算法的空间复杂度为$$O(n)$$。
#### 2.7.7 算法优化拓展
1. 找lowcost最小值时使用优先队列，每次出队一个最小值，时间复杂度为$$logn$$，执行n次，总时间复杂度为$$O(nlogn)$$。
2. 采用邻接表存储，这样更新的时间复杂度为$$O(Elogn)$$。

***
*第二种求最小生成树的方法(Kruskal)*
算法步骤：
1. 初始化。将图G的边集E中的所有边按权值从小到大排序，边集TE={}，吧每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。
2. 在E中寻找权值最小的边(i, j)。
3. 如果顶点i和j位于两个不同的连通分支，则将边(i,j)加入边集TE，并执行合并操作，将两个连通分支进行合并。
4. 将边(i,j)从集合E中删去，即E=E-{(i,j)}。
5. 如果选取边数小于n-1，转步骤2，否则，算法结束，生成最小生成树T。

#### 算法复杂度分析
1. 时间复杂度: 算法中，需要对边进行排序，如使用快排，执行次数为$$e*loge$$，算法的时间复杂度为$$O(e*loge)$$。而合并合并集合需要执行$$n-1$$次合并，每次为$$O(n)$$，合并集合的时间复杂度为$$O(n^2)$$。
2. 空间复杂度: 算法所需要的辅助空间包含集合号数组nodeset[n]，则算法的空间复杂度为$$O(n)$$。

#### 算法优化及拓展
该算法合并集合的时间复杂度为$$O(n^2)$$，我们可以用并查集的思想优化，使合并集合的时间复杂度降为$$O(e*logn)$$。优化后的程序如下。
#### 两种算法的比较
1. 从算法的思想可以看出，如果图G中的边数较小时，可以采用Kruskal算法，因为Kruskal算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适合用于稀疏图，而Prim算法适合稠密图。
2. 从时间上讲，Prim算法的时间复杂度为$$O(n^2)$$，Kruskal算法的时间复杂度为$$O(eloge)$$。
3. 从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V-U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。

#### 附录E---并查集
1. 并查集
并查集是一种树形数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询的问题。
(1) 初始化
把每个点所在集合初始化为其自生。
(2) 查找
查找两个元素所在的集合，即找祖宗。注意：查找时，采用递归的方法找其祖宗，祖宗集合等于自己时即停止。在回归时，把当前结点到祖宗路径上的所有结点统一为祖宗的集合号。
(3) 合并
如果两个元素的集合号不同，将两个元素合并为一个集合。注意：合并时只需要把一个元素的祖宗集合号，改为另一个元素的祖宗集合号。擒贼先擒王，只改祖宗即可！

## Chapter3 分治法(递归是一种用于实现分治法常用的算法，但是也可以使用其他算法实现分治法，比如使用while(l<=r)等)
分而治之是一种很古老但很实用的策略，或者说战略,本意是将一个较大的力量打碎分成小的力量，这样每个小的力量都不足以对抗大的力量。在现实应用中，分而治之往往是将大片区域分成小块区域治理。
### 3.1 山高皇帝远
#### 3.1.1 治众如治寡---分而治之
在算法设计中，我们也引入分而治之的策略，称为分治算法，其本质就是将一个大规模的问题分解为若干个规模较小的相同子问题，分而治之。
#### 3.1.2 天时地利人和---分治算法要素
那么在现实生活中，什么样的问题才能使用分治法解决呢?简单来说，需要满足以下3个条件。
1. 原问题可分解为若干个规模较小的相同子问题。
2. 子问题相互独立。
3. 子问题的解可以合并为原问题的解。
#### 3.1.3 分治算法秘籍
分治法解题的一般步骤如下。
1. 分解: 将要解决的问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。
2. 治理: 求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分得足够小时，就可以用较较简单的方法解决。
3. 合并: 按原问题的要求，将子问题的解逐层合并构成原问题的解。
一言以蔽之，分治法就是将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

**注意！分治算法和递归算法的关系**
**(递归是一种用于实现分治法常用的算法，但是也可以使用其他算法实现分治法，比如使用while(l<=r)等)**
**在分治算法中，各个子问题形式相同，解决的方法也一样，因此我们可以使用递归算法快速解决，递归是彰显分治法优势的利器。**

### 3.2 猜数游戏---二分搜索技术
#### 3.2.2 算法设计
算法设计：用一维数组s[]存储该有序序列，设变量low和high表示查找范围的下界和上界，middle表示查找范围的中间位置，x为特定的查找元素。
1. 初始化。令low=0,即指向有序数组s[]的第一个元素；high=n-1，即指向有序数字s[]的最后一个元素。
2. middle=(low+high)/2，即指示查找范围的中间元素。
3. 判定$$low \leq high$$是否成立，如果成立，转第四步，否则，算法结束。
4. 判定x与s[middle]的关系。如果x=S[middle]，则搜索成功，算法结束；如果x>s[middle],则令lowmiddle+1；否则令high=middl-1，转为第2步。
#### 3.2.6 算法解析与拓展
- 算法复杂度分析
1. 时间复杂度: 首先需要进行排序，调用sort函数。进行排序复杂度为$$O(nlogn)$$，如果数列本身有序，那么这部分不用考虑。二分查找的时间复杂度为$$O(logn)$$。
2. 空间复杂度：程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为$$O(1)$$。
- 优化拓展
使用递归来实现二分查找。
1. 时间复杂度: 使用递归查找时间复杂度不变$$O(logn)$$。
2. 空间复杂度: 二分搜索递归算法的空间复杂度为$$O(logn)$$。

### 3.3 合久必分，分久闭合---合并排序
#### 3.3.1 问题分析
合并排序就是采用分治的策略。可以把待排序元素分解成两个规模大致相等的子序列。如果不易解决，在将得到的子序列继续分解，直到子序列中包含的元素个数为1。
#### 3.3.2 算法设计
合并排序是采用分治策略实现对n个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡，简单的二分分治策略，过程大致分为:
1. 分解：将待排序元素分成大小大致相同的两个子序列。
2. 治理：对两个子序列进行合并排序。
3. 合并：将排序好的有序子序列进行合并得到最终的有序序列。
#### 3.3.6 算法解析与拓展
- 算法复杂度分析
1. 时间复杂度：
分解：这一步仅仅是计算出子序列的中间位置，需要常数时间$$O(1)$$。
解决子问题: 合并排序算法的时间复杂度为$$O(nlogn)$$。
2. 空间复杂度: 每调用一次合并，会分配一个适当大小的缓冲区，且退出时释放，最多分配大小为n，所以空间复杂度为$$O(n)$$。递归调用所使用的栈空间是$$O(logn)$$。第x层递归的规模为$$n/2^x$$，因为叶子结点只有一个结点因此在第x层$$1=n/2^x$$，则$$n=2^x, x=logn$$。因此递归树的深度为$$logn$$。
-优化拓展
上面算法我们使用递归来实现，当然也可以使用非递归的方法，大家可以动手试试。
### 3.4 兵贵神速---快速排序
#### 3.4.1 问题分析
合并排序分解容易，合并难，属于先易后难，并且是一种异地排序方法。而快速排序是原地排序，不需要辅助数组，但分解困难，合并容易，是先苦后甜型。
#### 3.4.2 算法设计
快速排序的基本思想是基于分治策略的，其算法思想如下。
1. 分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
2. 治理：对两个子序列进行快速排序。
3. 合并：将排好序的两个子序列合并在一起，得到原问题的解。
一般来说，基准元素选取有以下几种方法：
- 取第一个元素
- 取最后一个元素
- 取中间位置元素
- 取第一个，最后一个，中间位置元素三者之中位数。
- 取第一个和最后一个之间位置的随机数。
#### 3.4.6 算法解析与拓展
- 算法复杂度分析
1. 最好时间复杂度：
分解：划分函数需要扫描每个元素，每次扫描的元素个数不超过n，因此时间复杂度为$$O(n)$$。
快速排序最好的时间复杂度为$$O(nlogn)$$。
空间复杂度：递归调用所使用的栈空间是$$O(logn)$$。
2. 最坏时间复杂度:
快速排序算法最坏的时间复杂度为$$O(n^2)$$。
最坏空间复杂度：递归调用所使用的栈空间是$$O(n)$$。
3. 快速排序算法平均情况下，时间复杂度为$$O(nlogn)$$，递归调用所使用的栈空间也是$$O(logn)$$。
### 3.5 效率至上1---大整数乘法
#### 3.5.1 问题分析
在解决2个大的整数相乘时，我们可以将一个大的整数乘法分而治之，将大问题变成小问题，变成简单的小数乘法再进行合并，从而解决上述问题。这样既解决了计算机硬件处理的问题，又能够提高乘法的计算效率。
#### 3.5.3 算法设计
#### 3.5.6 算法解析与拓展
- 算法复杂度分析
1. 时间复杂度：大整数乘法的时间复杂度为$$O(n^2)$$。
2. 空间复杂度：程序中变量占用了一些辅助空间，都是常数阶的，但合并时结点数组占用的辅助空间为$$O(n)$$，递归调用所使用的栈空间是$$O(logn)$$。大整数乘法的空间复杂度为$$O(n)$$。
- 优化拓展
优化改进后的大整数乘法的时间复杂度从$$O(n^2)$$ 降为$$O(n^1.59)$$，这是一个巨大的改进。但是需要注意：在上面的公式中，A和B必须为$$2^n$$位。
### 3.6 分治算法复杂度求解秘籍

## Chapter4 动态规划
前面讲的分治法是将原问题分解为若干个规模较小，形式相同的子问题，然而求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是相互不相交的，即相互对立。如果各个子问题有重叠，不是相互独立的，那么用分治法就重复求解了很多子问题，根本显示不了分治的优势，反而降低了算法效率。那么就提出了改进算法，动态规划。
### 4.1 神奇的兔子序列
斐波那契数列。
### 4.2 动态规划算法基础
#### 4.2.1算法思想
动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解位若干子问题，自顶向下求解各子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格中，在求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高计算效率。
#### 4.2.2 算法要素
**什么问题可以使用动态规划呢？我们首先要分析问题是否具有以下两个性质：**
1. 最优子结构
**最优子结构性质是指问题的最优解包含其子问题的最优解。最优子结构是使用动态规划的最基本条件，如果不具有最优子结构性质，就不可以使用动态规划解决。**
2. 子问题重叠
子问题重叠是指在求解子问题的过程中，有大量的子问题是重复的，那么只需求解一个词，然后把结果存储在表中，以后使用时可以直接查询，不需要再次求解。子问题重叠不是使用动态规划的必要条件，但问题存在子问题重叠更能够充分彰显动态规划的优势。
#### 4.2.3 解题秘籍
遇到一个实际问题，如何采用动态规划来解决呢？
1. 分析最优解的结构特征。
2. 建立最优值的递归式。
3. 自底向上计算最优值，并记录。
4. 构造最优解。
### 4.3 孩子有多像爸爸---最长的公共子序列
#### 4.3.2算法设计
最长公共子序列问题满足动态规划的最优子结构性质，可以自底向上逐步得到最优解。
1. 确定合适的数据结构
采用二维数组c[][]来记录最长公共子序列的长度，二维数组b[][]来记录最长公共子序列的长度来源。
2. 初始化
c[][]第一行第一列元素为0。
3. 循环阶段
4. 构造最优解
5. 

$$c[i][j] = \begin{cases} 0, & \text{i=0 或 j=0} \\[5ex] c[i-1][j-1]+1, & \text{i,j $\gt$ 0 且 x = y} \\[5ex] max \{ c[i][j-1], c[i-1][j] \}, & \text{x $\ne$ j}  \end{cases}$$

#### 4.3.6 算法解析及优化拓展
- 算法复杂度分析
1. 算法时间复杂度： 由于每个数组单元的计算耗费$$O(1)$$ 时间，如果两个字符串的长度分别是m，n，那么算法时间复杂度为$$O(m*n)$$。
2. 空间1复杂度: 空间复杂度主要为两个二维数组c[][],b[][],占用的空间为$$O(m*n)$$。
### 4.4 DNA基因鉴定---编辑距离
#### 4.4.1 问题分析
编辑距离是指将一个字符串变换为另一个字符串所需的最小编辑操作。
#### 4.4.2 算法设计
编辑距离问题满足动态规划的最优子结构性质，可以自底向上逐渐推出整体最优解。
1. 确定合适的数据结构
采用二维数组d[][]来记录编辑距离。
2. 初始化
d[][]第一行为0，1，2，3，...,len2，第一列元素为0，1，2，...，len1。
3. 循环阶段
递推式：$$d[i][j] = min\{dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+diff(i,j)\}$$。如果s[i] == s[j], diff(i,j) = 0, 否则diff[i][j]=1。
4. 构造最优解
从d[i][j]表格中倒推，输出插入，删除，替换了哪些字母。在此没有使用辅助数组，采用判断的方式倒推。
#### 4.4.4 完美图解
上面dp[i][j]=dp[i-1][j]+1 表示需要删除。
左侧dp[i][j]=dp[i][j-1]+1 表示需要插入。
左上角dp[i][j]=dp[i-1][j-1]+diff(i,j)要判断是否字符相等，如果不相等则需要替换，如果字符相等什么也不做。
#### 4.4.6 算法解析及优化拓展
-算法复杂度分析
1. 时间复杂度：算法有两个for循环，一个双重for循环。如果两个字符串的长度分别为m，n，前两个for循环时间复杂度为$$O(n)$$，$$O(m)$$，双重for循环时间复杂度为$$O(n*m)$$，所以总时间复杂度为$$O(n*m)$$。
2. 空间复杂度：使用了d[][]数组，空间复杂度为$$O(n*m)$$。
### 4.5长江一日游---游艇租赁
#### 4.5.1 问题分析
1. 分析最优解的结构特征
从第一站到第n站的最优解是否一定包含前n-1的最优解，即是否具有最优子结构和重叠性。如果是，就可以利用动态规划进行求解。
2. 建立最优值的递归式
用m[i][j]表示第i个站点到第j个站点(i,i+1,....j)的最优值(最少租金)，那么两个子问题：(i,i+1,...,k)，(k,k+1,...,j)对应的最优值分别是m[i][k]，m[k][j]。
$$m[i][j] = \begin{cases} 0, & \text{i=j} \\[5ex] r[i][j], & \text{j = i+1} \\[5ex] min \{ m[i][k] + m[k][j], r[i][j] \}, & \text{j>i+1 且 i<k<j}  \end{cases}$$
3. 自底向上计算最优值，并记录
先求两个站点之间的最优值，在求3个站点之间的最优值，直到n个站点之间的最优值。
4. 构造最优解
上面得到的最优值只是第一个站点到第n个站点之间的最少租金，我们需要从记录表中还原，逆向构造出最优解。
#### 4.5.2 算法设计
采用自底向上的方法求最优值，分为不同规模的子问题，对于每一个小的子问题都求最优值，记录最优策略，具体策略如下。
1. 确定合适的数据结构
采用二维数组r[][]输入数据，二维数组m[][]存放各个子问题的最优值，二维数组s[][]存放各个子问题的最优策略(停靠站点)。
2. 初始化
根据递推公式，可以把m[i][j]初始化为r[i][j]，然后再找有没有比m[i][j]小的值，如果有，则记录该最优值和最优解即可。s[i][j]=0;
3. 循环阶段
按照递归式求三个站点，按照递归式求解4个站点，等等，直到求出n个站点的最优值m[1][n]。
4. 构造最优解
根据最优决策信息数组s[][]递归构造最优解。s[1][n]是第1个站点到第n个站点(1,2,...,n)的最优解的停靠站点，即停靠了第s[1][n]个站点。
#### 4.5.6 算法解析及优化拓展
-算法复杂度分析
1. 时间复杂度：由程序可以得出：语句temp=m[i][k]+m[k][i]，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为$$O(n^3)$$，print()函数算法的时间主要取决于递归，最坏情况下时间复杂度为$$O(n)$$。故该程序的时间复杂度为$$O(n^3)$$。
2. 空间复杂度：该程序的输入数据的数组为r[][]，辅助变量为i，j，r，t，k，m[][]，s[][]，空间复杂度取决于辅助空间，该程序的空间复杂度为$$O(n^2)$$。
-算法优化拓展
如果只是想得到最优值，则不需要s[][]数组；m[][]数组也可以省略，直接在r[][]数组上更新即可，这样空间复杂度减少为$$O(1)$$。

### 4.6 快速计算矩阵连乘
#### 4.6.1问题分析
1. 什么是矩阵可乘？
如果两个矩阵，第1个矩阵的列等于第2个矩阵的行时，那么这两个矩阵是可乘的。
2. 矩阵相乘后的结果是什么？
多个矩阵相乘的结果矩阵，其行，列分别等于1个矩阵的行，最后1个矩阵的列。而且无论矩阵的计算次序如何都不影响它们的结果矩阵。
3. 矩阵中数的计算次数
$$_{Am*n}$$， $$_{An*k}$$ 相乘执行乘法运算的次数为$$m*n*k$$。
1. 分析最优解的结构特征
2. 建立最优值递归式
3. 自底向上计算并记录最优值
先求两个矩阵相乘的最优值，在求3个矩阵相乘的最优值，直到n个矩阵连乘的最优值。
4. 构造最优解
$$m[i][j] = \begin{cases} 0, & \text{i=j} \\[5ex] min \{ m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j] \}, & \text{i<j 且 k>=i 且 k<j}  \end{cases}$$
#### 4.6.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度：该程序的时间复杂度为$$O(n^3)$$。
2. 空间复杂度：空间复杂度为$$O(n^2)$$。

**动态规划最关键的一点是原问题的最优解包含子问题的最优解(即具有最优子结构性质)**
### 切呀切披萨---最优三角部分
#### 4.7.1 问题分析
凸多边形：凸多边形是指多边形的任意两点的连线均落在多边形的内部或边界上。
凸多边形不相邻的两个顶点的连线称为凸多边形的弦。
凸多边形的三角抛分是指将一个凸多边形分割成互不相交的三角形的弦的集合。一个凸多边形的三角抛分有很多种。
解题步骤：
首先分析该问题是否具有最优子结构性质。
1. 分析最优解的结构特征
2. 建立最优值的递归式
$$m[i][j] = \begin{cases} 0, & \text{i=j} \\[5ex] min \{ m[i][k] + m[k+1][j] + w(vi,vk,vj) \}, & \text{i<j 且 k>=i 且 k<j}  \end{cases}$$
3. 自底向上计算并记录最优值
先求只有3个顶点凸多边形三角抛分的最优值，在求4个顶点凸多边形三角抛分的最优指，直到n个顶点凸多边形三角抛分的最优值。
4. 构造最优解

凸多边形最优三角抛分的问题，首先判断该问题是否具有最优子结构性质，有了这个性质就可以使用动态规划，然后分析问题找最优解的递归式，根据递归式自底向上求解，然后根据最优决策表格，构造出最优解。

#### 4.7.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度： 该程序的时间复杂度为$$O(n^3)$$。
2. 空间复杂度：空间复杂度为$$O(n^2)$$。
- 算法优化拓展
这个问题尽管和矩阵连乘问题表达的含义不同，但递归式是完全相同的，那么程序代码就可以参考矩阵连乘的代码了。

### 4.8 小石子游戏---石子合并 









# Dillinger
## _The Last Markdown Editor, Ever_

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://nodesource.com/products/nsolid)

[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

Dillinger is a cloud-enabled, mobile-ready, offline-storage compatible,
AngularJS-powered HTML5 Markdown editor.

- Type some Markdown on the left
- See HTML in the right
- ✨Magic ✨

## Features

- Import a HTML file and watch it magically convert to Markdown
- Drag and drop images (requires your Dropbox account be linked)
- Import and save files from GitHub, Dropbox, Google Drive and One Drive
- Drag and drop markdown and HTML files into Dillinger
- Export documents as Markdown, HTML and PDF

Markdown is a lightweight markup language based on the formatting conventions
that people naturally use in email.
As [John Gruber] writes on the [Markdown site][df1]

> The overriding design goal for Markdown's
> formatting syntax is to make it as readable
> as possible. The idea is that a
> Markdown-formatted document should be
> publishable as-is, as plain text, without
> looking like it's been marked up with tags
> or formatting instructions.

This text you see here is *actually- written in Markdown! To get a feel
for Markdown's syntax, type some text into the left window and
watch the results in the right.

## Tech

Dillinger uses a number of open source projects to work properly:

- [AngularJS] - HTML enhanced for web apps!
- [Ace Editor] - awesome web-based text editor
- [markdown-it] - Markdown parser done right. Fast and easy to extend.
- [Twitter Bootstrap] - great UI boilerplate for modern web apps
- [node.js] - evented I/O for the backend
- [Express] - fast node.js network app framework [@tjholowaychuk]
- [Gulp] - the streaming build system
- [Breakdance](https://breakdance.github.io/breakdance/) - HTML
to Markdown converter
- [jQuery] - duh

And of course Dillinger itself is open source with a [public repository][dill]
 on GitHub.

## Installation

Dillinger requires [Node.js](https://nodejs.org/) v10+ to run.

Install the dependencies and devDependencies and start the server.

```sh
cd dillinger
npm i
node app
```

For production environments...

```sh
npm install --production
NODE_ENV=production node app
```

## Plugins

Dillinger is currently extended with the following plugins.
Instructions on how to use them in your own application are linked below.

| Plugin | README |
| ------ | ------ |
| Dropbox | [plugins/dropbox/README.md][PlDb] |
| GitHub | [plugins/github/README.md][PlGh] |
| Google Drive | [plugins/googledrive/README.md][PlGd] |
| OneDrive | [plugins/onedrive/README.md][PlOd] |
| Medium | [plugins/medium/README.md][PlMe] |
| Google Analytics | [plugins/googleanalytics/README.md][PlGa] |

## Development

Want to contribute? Great!

Dillinger uses Gulp + Webpack for fast developing.
Make a change in your file and instantaneously see your updates!

Open your favorite Terminal and run these commands.

First Tab:

```sh
node app
```

Second Tab:

```sh
gulp watch
```

(optional) Third:

```sh
karma test
```

#### Building for source

For production release:

```sh
gulp build --prod
```

Generating pre-built zip archives for distribution:

```sh
gulp build dist --prod
```

## Docker

Dillinger is very easy to install and deploy in a Docker container.

By default, the Docker will expose port 8080, so change this within the
Dockerfile if necessary. When ready, simply use the Dockerfile to
build the image.

```sh
cd dillinger
docker build -t <youruser>/dillinger:${package.json.version} .
```

This will create the dillinger image and pull in the necessary dependencies.
Be sure to swap out `${package.json.version}` with the actual
version of Dillinger.

Once done, run the Docker image and map the port to whatever you wish on
your host. In this example, we simply map port 8000 of the host to
port 8080 of the Docker (or whatever port was exposed in the Dockerfile):

```sh
docker run -d -p 8000:8080 --restart=always --cap-add=SYS_ADMIN --name=dillinger <youruser>/dillinger:${package.json.version}
```

> Note: `--capt-add=SYS-ADMIN` is required for PDF rendering.

Verify the deployment by navigating to your server address in
your preferred browser.

```sh
127.0.0.1:8000
```

## License

MIT

**Free Software, Hell Yeah!**

[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen. Thanks SO - http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax)

   [dill]: <https://github.com/joemccann/dillinger>
   [git-repo-url]: <https://github.com/joemccann/dillinger.git>
   [john gruber]: <http://daringfireball.net>
   [df1]: <http://daringfireball.net/projects/markdown/>
   [markdown-it]: <https://github.com/markdown-it/markdown-it>
   [Ace Editor]: <http://ace.ajax.org>
   [node.js]: <http://nodejs.org>
   [Twitter Bootstrap]: <http://twitter.github.com/bootstrap/>
   [jQuery]: <http://jquery.com>
   [@tjholowaychuk]: <http://twitter.com/tjholowaychuk>
   [express]: <http://expressjs.com>
   [AngularJS]: <http://angularjs.org>
   [Gulp]: <http://gulpjs.com>

   [PlDb]: <https://github.com/joemccann/dillinger/tree/master/plugins/dropbox/README.md>
   [PlGh]: <https://github.com/joemccann/dillinger/tree/master/plugins/github/README.md>
   [PlGd]: <https://github.com/joemccann/dillinger/tree/master/plugins/googledrive/README.md>
   [PlOd]: <https://github.com/joemccann/dillinger/tree/master/plugins/onedrive/README.md>
   [PlMe]: <https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md>
   [PlGa]: <https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md>
