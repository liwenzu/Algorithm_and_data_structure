# 趣学算法

## Chapter1

时间复杂度：考察一个算法通常考察最坏情况，而不是考察最好情况，最坏情况对衡量算法的好坏具有实际意义。

空间复杂度: 辅助空间使衡量空间复杂度的关键因素。

注意！
在递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。

阶乘是典型的递归调用问题，递归包括递推和回归。递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。

常见的算法时间复杂度有以下几类:
- 常数阶
$$O(1)$$
- 多项式阶
很多算法的时间复杂度是多项式，通常用$$O(n)$$, $$O(n^2)$$, $$O(n^3)$$ 等表示。
- 指数阶
如: $$O(2^n)$$, $$O(n!)$$, $$O(n^n)$$ 等。
- 对数阶
-对数阶时间复杂度运行效率较高，常见的有$$O(logn)$$, $$O(nlogn)$$。

注意！

斐波那契数列既可以使用递归方法求解(包含大量重复计算，因此时间复杂度是指数阶)，也可以使用动态规划求解$$O(n)$$。

算法策略: 贪心，分治，动态规划， 线性规划，搜索等；

本章主要说明以下问题:
- 将程序的执行次数作为时间复杂度的衡量标准；
- 时间复杂度通常用渐近上界符号$$f(n)$$ 表示；
- 衡量算法的好坏通常考察算法的最坏情况；
- 空间复杂度只计算辅助空间；
- 递归算法的空间复杂度要计算递归使用的栈空间；
- 设计算法时尽量避免爆炸级增量复杂度；

## Chapter2 贪心算法

### 2.1 人之初，性本贪

一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。

在贪心算法中，注意以下几个问题:
- 一旦做出选择，不可以反悔；
- 有可能得到的不是最优解，而是最优的近似解；
- 选择什么样的贪心策略，直接决定算法的好坏；

贪心算法具有2个重要特征:
- 贪心选择；
运用贪心策略解决的问题在程序运行过程中无回溯过程。
- 最优子结构；
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。

贪心算法的过程:
- 贪心策略
首先要确定贪心策略，选择当前看上去最好的一个方案。
- 局部最优解
根据贪心策略，一步一步地得到局部最优解。
- 全局最优解
把所有全部局部最优解合并成为原来问题的一个最优解。

比如冒泡算法使用了贪心算法。

### 2.2 加勒比海盗船---最优装载问题

问题分析：
要求装载的物品的数量尽可能的多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。采用重量最轻者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题你的最优解。

#### 2.2.6 算法解析及优化拓展
- 算法复杂度分析:
1. 时间复杂度: 排序平均复杂度$$O(nlogn)$$, 输入和贪心策略$$O(n)$$, 因此时间复杂度为 $$O(n+nlogn)$$。
2. 空间复杂度：$$O(1)$$。

### 2.3 阿里巴巴与四十大盗---背包问题
#### 2.3.1 问题分析
假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v, 毛驴运载能力有限， 只能运走m重量的宝物，一种宝物只能拿走一件，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢?
#### 2.3.2 算法设计
- 将n种宝物的重量和价值存储在结构体中(包含重量，价值，性价比3个成员)，同时求出每种宝物的性价比也存储在对应的结构体中，将其按照性价比从高到底排序。
- 根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。
#### 2.3.6 算法解析及优化拓展
- 算法复杂度分析 
1. 时间复杂度: 该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为$$O(nlogn)$$。 
2. 空间复杂度: 空间主要耗费在存储宝物的性价比，空间复杂度为$$O(n)$$。

**在物品不可分割，没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。**
**物品可分割的装载问题称为背包问题，物体不可分割的装载问题称之为0-1背包问题。**
**在物品不可分割的情况下，即0-1背包问题，已经不具有贪心选择性质，原问题的整体最优解无法通过一系列局 部最优的选择得到，因此这类问题得到的是近似解。如果一个问题不要求得到最优解，而只需要一个最优解的近似解，则不管该问题有没有贪心选择性质都可以使用贪心算法。**

### 2.4 高级钟点秘书---会议安排
#### 2.4.1 问题分析
贪心策略: 每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排。
#### 2.4.2 算法设计
- 初始化: 将n个会议的开始时间，结束时间存放在结构体数组中，如果需要知道选择了哪些会议，还需要在结构体中增加会议编号，然后按照结束时间从小到大排序，结束时间相等时，按开始时间从大到小排序；
- 根据贪心策略就是选择第一个具有最早结束时间的会议，用last记录刚选中会议的结束时间；
- 选择第一个会议之后，依次从剩余下未安排的会议中选择，如果会议i开始时间大于等于最后一个选中的会议的结束时间last，那么会议i与选中的会议相容，可以安排，更新last为刚选中会议的结束时间；否则，舍弃会议i,检查下一个会议是否可以安排。
#### 2.4.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度:
排序的平均时间复杂度为$$O(nlogn)$$, 会议选择的时间复杂度为$$O(n)$$ , 因此总的时间复杂度为$$O(n+nlogn) = O(nlogn)$$ 。
2. 空间复杂度: 
在该算法中，结构数组作为输入数据，不计算在空间复杂度内。因此该程序空间复杂度为常数阶，即$$O(1)$$。
### 2.5 一场说走就走的旅行---最短路径

#### 2.5.1 问题分析
根据题目描述可知，这是一个求单源最短路径的问题。给定有向带权图$$G = (V, E)$$, 其中每条边的权是非负实数。此外，给定V中的一个顶点，称为源点。现在要计算从源到所有其他各个顶点的最短路径长度，这里路径长度指路上各边的权之和。使用Dijkstra算法。
#### 2.5.2 算法设计
Dijkstra算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，在参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径。
Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径，将其连接的V-S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，Dist[]就是从源到所有其他顶点之间的最短路径长度。
#### 2.5.6 算法解析及优化拓展
- 算法复杂度分析
1. 时间复杂度:
算法的时间复杂度为$$O(n^2)$$。
2. 空间复杂度:
实现该算法所需的辅助空间包含为数组flag, 变量i, j ,t 和temp所分配的空间，因此，空间复杂度为$$O(n)$$。
- 算法优化拓展
使用优先队列。
优先队列概念:
普通优先队列是一种先进先出的数据结构，元素在队尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。
优先队列(priority queue)具有最高级先出的行为特征。优先队列是0个或多个元素的集合，每个元素都有一个优先权或值。
在最小优先队列(min priority queue)中，查找操作用来搜索优先权最小的元素，删除操作用来删除该元素；对于最大优先队列(max priority queue), 查找操作用来搜索优先权最大的元素,删除操作用来删除该元素。(默认是最大优先队列)
在集合V-S中寻找距离源点u最近的顶点t,其时间复杂度为$$O(n)$$，如果我们使用优先队列，则可以把是按复杂度降为$$O(logn)$$。
**注意!**
使用优先队列的时间复杂度:
1. 使用邻接矩阵存储
语句总的执行次数为$$n*logn + n^2*logn$$， 算法的时间复杂度为$$O(n^2logn)$$。
2. 使用邻接表存储
总的时间复杂度为$$O(n*logn + E*logn)$$，如果 $$E \geq n$$，则时间复杂度为$$O(E*logn)$$。
优先队列中尽管有重复的结点，但重复结点最坏是$$n^2$$, $$logn^2 = 2logn$$，并不改变时间复杂度的数量级。
想一想，还能不能把时间复杂度在降低呢? 如果我们使用斐波那契堆，那么松弛操作的时间复杂度$$O(1)$$，总的时间复杂度为$$O(n*logn+E)$$。每个结点的邻接边加起来为边数E。
**!!!在STL容器中，优先队列的底层，是按照堆的形式实现的(默认为大根堆)。**

### 2.6 神秘电报密码---哈夫曼编码
#### 2.6.2 算法设计
哈夫曼编码的基本思想是以字符的使用频率作为权构建一颗哈夫曼树，然后利用哈夫曼树对字符进行编码。构建一棵哈夫曼树，是将所有编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式,通过n-1次的合并运算后构建出的一棵树，核心思想是权值越大的叶子结点离根越近。
哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中。












# Dillinger
## _The Last Markdown Editor, Ever_

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://nodesource.com/products/nsolid)

[![Build Status](https://travis-ci.org/joemccann/dillinger.svg?branch=master)](https://travis-ci.org/joemccann/dillinger)

Dillinger is a cloud-enabled, mobile-ready, offline-storage compatible,
AngularJS-powered HTML5 Markdown editor.

- Type some Markdown on the left
- See HTML in the right
- ✨Magic ✨

## Features

- Import a HTML file and watch it magically convert to Markdown
- Drag and drop images (requires your Dropbox account be linked)
- Import and save files from GitHub, Dropbox, Google Drive and One Drive
- Drag and drop markdown and HTML files into Dillinger
- Export documents as Markdown, HTML and PDF

Markdown is a lightweight markup language based on the formatting conventions
that people naturally use in email.
As [John Gruber] writes on the [Markdown site][df1]

> The overriding design goal for Markdown's
> formatting syntax is to make it as readable
> as possible. The idea is that a
> Markdown-formatted document should be
> publishable as-is, as plain text, without
> looking like it's been marked up with tags
> or formatting instructions.

This text you see here is *actually- written in Markdown! To get a feel
for Markdown's syntax, type some text into the left window and
watch the results in the right.

## Tech

Dillinger uses a number of open source projects to work properly:

- [AngularJS] - HTML enhanced for web apps!
- [Ace Editor] - awesome web-based text editor
- [markdown-it] - Markdown parser done right. Fast and easy to extend.
- [Twitter Bootstrap] - great UI boilerplate for modern web apps
- [node.js] - evented I/O for the backend
- [Express] - fast node.js network app framework [@tjholowaychuk]
- [Gulp] - the streaming build system
- [Breakdance](https://breakdance.github.io/breakdance/) - HTML
to Markdown converter
- [jQuery] - duh

And of course Dillinger itself is open source with a [public repository][dill]
 on GitHub.

## Installation

Dillinger requires [Node.js](https://nodejs.org/) v10+ to run.

Install the dependencies and devDependencies and start the server.

```sh
cd dillinger
npm i
node app
```

For production environments...

```sh
npm install --production
NODE_ENV=production node app
```

## Plugins

Dillinger is currently extended with the following plugins.
Instructions on how to use them in your own application are linked below.

| Plugin | README |
| ------ | ------ |
| Dropbox | [plugins/dropbox/README.md][PlDb] |
| GitHub | [plugins/github/README.md][PlGh] |
| Google Drive | [plugins/googledrive/README.md][PlGd] |
| OneDrive | [plugins/onedrive/README.md][PlOd] |
| Medium | [plugins/medium/README.md][PlMe] |
| Google Analytics | [plugins/googleanalytics/README.md][PlGa] |

## Development

Want to contribute? Great!

Dillinger uses Gulp + Webpack for fast developing.
Make a change in your file and instantaneously see your updates!

Open your favorite Terminal and run these commands.

First Tab:

```sh
node app
```

Second Tab:

```sh
gulp watch
```

(optional) Third:

```sh
karma test
```

#### Building for source

For production release:

```sh
gulp build --prod
```

Generating pre-built zip archives for distribution:

```sh
gulp build dist --prod
```

## Docker

Dillinger is very easy to install and deploy in a Docker container.

By default, the Docker will expose port 8080, so change this within the
Dockerfile if necessary. When ready, simply use the Dockerfile to
build the image.

```sh
cd dillinger
docker build -t <youruser>/dillinger:${package.json.version} .
```

This will create the dillinger image and pull in the necessary dependencies.
Be sure to swap out `${package.json.version}` with the actual
version of Dillinger.

Once done, run the Docker image and map the port to whatever you wish on
your host. In this example, we simply map port 8000 of the host to
port 8080 of the Docker (or whatever port was exposed in the Dockerfile):

```sh
docker run -d -p 8000:8080 --restart=always --cap-add=SYS_ADMIN --name=dillinger <youruser>/dillinger:${package.json.version}
```

> Note: `--capt-add=SYS-ADMIN` is required for PDF rendering.

Verify the deployment by navigating to your server address in
your preferred browser.

```sh
127.0.0.1:8000
```

## License

MIT

**Free Software, Hell Yeah!**

[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen. Thanks SO - http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax)

   [dill]: <https://github.com/joemccann/dillinger>
   [git-repo-url]: <https://github.com/joemccann/dillinger.git>
   [john gruber]: <http://daringfireball.net>
   [df1]: <http://daringfireball.net/projects/markdown/>
   [markdown-it]: <https://github.com/markdown-it/markdown-it>
   [Ace Editor]: <http://ace.ajax.org>
   [node.js]: <http://nodejs.org>
   [Twitter Bootstrap]: <http://twitter.github.com/bootstrap/>
   [jQuery]: <http://jquery.com>
   [@tjholowaychuk]: <http://twitter.com/tjholowaychuk>
   [express]: <http://expressjs.com>
   [AngularJS]: <http://angularjs.org>
   [Gulp]: <http://gulpjs.com>

   [PlDb]: <https://github.com/joemccann/dillinger/tree/master/plugins/dropbox/README.md>
   [PlGh]: <https://github.com/joemccann/dillinger/tree/master/plugins/github/README.md>
   [PlGd]: <https://github.com/joemccann/dillinger/tree/master/plugins/googledrive/README.md>
   [PlOd]: <https://github.com/joemccann/dillinger/tree/master/plugins/onedrive/README.md>
   [PlMe]: <https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md>
   [PlGa]: <https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md>
